.TH script 5 "sasl 2.1.10" "Ericsson AB" "Files"
.SH NAME
script \- Boot script
.SH DESCRIPTION
.LP
The \fIboot script\fR\& describes how the Erlang runtime system is started\&. It contains instructions on which code to load and which processes and applications to start\&.
.LP
The command \fIerl -boot Name\fR\& starts the system with a boot file called \fIName\&.boot\fR\&, which is generated from the \fIName\&.script\fR\& file, using \fIsystools:script2boot/1\fR\&\&.
.LP
The \fI\&.script\fR\& file is generated by \fIsystools\fR\& from a \fI\&.rel\fR\& file and \fI\&.app\fR\& files\&.
.SH "FILE SYNTAX"

.LP
The boot script is stored in a file with the extension \fI\&.script\fR\&
.LP
The file has the following syntax:
.LP
.nf

{script, {Name, Vsn},
 [
  {progress, loading},
  {preLoaded, [Mod1, Mod2, ...]},
  {path, [Dir1,"$ROOT/Dir",...]}.
  {primLoad, [Mod1, Mod2, ...]},
  ...
  {kernel_load_completed},
  {progress, loaded},
  {kernelProcess, Name, {Mod, Func, Args}},
  ...
  {apply, {Mod, Func, Args}},
  ...
  {progress, started}]}.    
.fi
.RS 2
.TP 2
*
\fIName = string()\fR\& defines the name of the system\&. 
.LP
.TP 2
*
\fIVsn = string()\fR\& defines the version of the system\&. 
.LP
.TP 2
*
\fI{progress, Term}\fR\& sets the "progress" of the initialization program\&. The function \fIinit:get_status()\fR\& returns the current value of the progress, which is \fI{InternalStatus,Term}\fR\&\&. 
.LP
.TP 2
*
\fI{path, [Dir]}\fR\& where \fIDir\fR\& is a string\&. This argument sets the load path of the system to \fI[Dir]\fR\&\&. The load path used to load modules is obtained from the initial load path, which is given in the script file, together with any path flags which were supplied in the command line arguments\&. The command line arguments modify the path as follows:
.RS 2
.TP 2
*
\fI-pa Dir1 Dir2 \&.\&.\&. DirN\fR\& adds the directories \fIDir1, Dir2, \&.\&.\&., DirN\fR\& to the front of the initial load path\&. 
.LP
.TP 2
*
\fI-pz Dir1 Dir2 \&.\&.\&. DirN\fR\& adds the directories \fIDir1, Dir2, \&.\&.\&., DirN\fR\& to the end of the initial load path\&. 
.LP
.TP 2
*
\fI-path Dir1 Dir2 \&.\&.\&. DirN\fR\& defines a set of directories \fIDir1, Dir2, \&.\&.\&., DirN\fR\& which replaces the search path given in the script file\&. Directory names in the path are interpreted as follows:
.RS 2
.TP 2
*
Directory names starting with \fI/\fR\& are assumed to be absolute path names\&. 
.LP
.TP 2
*
Directory names not starting with \fI/\fR\& are assumed to be relative the current working directory\&. 
.LP
.TP 2
*
The special \fI$ROOT\fR\& variable can only be used in the script, not as a command line argument\&. The given directory is relative the Erlang installation directory\&. 
.LP
.RE

.LP
.RE

.LP
.TP 2
*
\fI{primLoad, [Mod]}\fR\& loads the modules \fI[Mod]\fR\& from the directories specified in \fIPath\fR\&\&. The script interpreter fetches the appropriate module by calling the function \fIerl_prim_loader:get_file(Mod)\fR\&\&. A fatal error which terminates the system will occur if the module cannot be located\&. 
.LP
.TP 2
*
\fI{kernel_load_completed}\fR\& indicates that all modules which \fImust\fR\& be loaded \fIbefore\fR\& any processes are started are loaded\&. In interactive mode, all \fI{primLoad,[Mod]}\fR\& commands interpreted after this command are ignored, and these modules are loaded on demand\&. In embedded mode, \fIkernel_load_completed\fR\& is ignored, and all modules are loaded during system start\&. 
.LP
.TP 2
*
\fI{kernelProcess, Name, {Mod, Func, Args}}\fR\& starts a "kernel process"\&. The kernel process \fIName\fR\& is started by evaluating \fIapply(Mod, Func, Args)\fR\& which is expected to return \fI{ok, Pid}\fR\& or \fIignore\fR\&\&. The \fIinit\fR\& process monitors the behaviour of \fIPid\fR\& and terminates the system if \fIPid\fR\& dies\&. Kernel processes are key components of the runtime system\&. Users do not normally add new kernel processes\&. 
.LP
.TP 2
*
\fI{apply, {Mod, Func, Args}}\fR\&\&. The init process simply evaluates \fIapply(Mod, Func, Args)\fR\&\&. The system terminates if this results in an error\&. The boot procedure hangs if this function never returns\&. 
.LP
.RE

.LP

.RS -4
.B
Note:
.RE
In the \fIinteractive\fR\& system the code loader provides demand driven code loading, but in the \fIembedded\fR\& system the code loader loads all the code immediately\&. The same version of \fIcode\fR\& is used in both cases\&. The code server calls \fIinit:get_argument(mode)\fR\& to find out if it should run in demand mode, or non-demand driven mode\&.

.SH "SEE ALSO"

.LP
systools(3)