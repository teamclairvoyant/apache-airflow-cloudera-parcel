.TH sets 3 "stdlib 1.17.5" "Ericsson AB" "Erlang Module Definition"
.SH NAME
sets \- Functions for Set Manipulation
.SH DESCRIPTION
.LP
Sets are collections of elements with no duplicate elements\&. The representation of a set is not defined\&.
.LP
This module provides exactly the same interface as the module \fIordsets\fR\& but with a defined representation\&. One difference is that while this module considers two elements as different if they do not match (\fI=:=\fR\&), \fIordsets\fR\& considers two elements as different if and only if they do not compare equal (\fI==\fR\&)\&.
.SH DATA TYPES
.nf

.B
\fBset()\fR\&
.br
.fi
.RS
.LP
As returned by \fInew/0\fR\&\&.
.RE
.SH EXPORTS
.LP
.nf

.B
new() -> set()
.br
.fi
.br
.RS
.LP
Returns a new empty set\&.
.RE
.LP
.nf

.B
is_set(Set) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Set = term()
.br
.RE
.RS
.LP
Returns \fItrue\fR\& if \fISet\fR\& is a set of elements, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
size(Set) -> integer() >= 0
.br
.fi
.br
.RS
.TP 3
Types:

Set = set()
.br
.RE
.RS
.LP
Returns the number of elements in \fISet\fR\&\&.
.RE
.LP
.nf

.B
to_list(Set) -> List
.br
.fi
.br
.RS
.TP 3
Types:

Set = set()
.br
List = [term()]
.br
.RE
.RS
.LP
Returns the elements of \fISet\fR\& as a list\&.
.RE
.LP
.nf

.B
from_list(List) -> Set
.br
.fi
.br
.RS
.TP 3
Types:

List = [term()]
.br
Set = set()
.br
.RE
.RS
.LP
Returns an set of the elements in \fIList\fR\&\&.
.RE
.LP
.nf

.B
is_element(Element, Set) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Element = term()
.br
Set = set()
.br
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIElement\fR\& is an element of \fISet\fR\&, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
add_element(Element, Set1) -> Set2
.br
.fi
.br
.RS
.TP 3
Types:

Element = term()
.br
Set1 = Set2 = set()
.br
.RE
.RS
.LP
Returns a new set formed from \fISet1\fR\& with \fIElement\fR\& inserted\&.
.RE
.LP
.nf

.B
del_element(Element, Set1) -> Set2
.br
.fi
.br
.RS
.TP 3
Types:

Element = term()
.br
Set1 = Set2 = set()
.br
.RE
.RS
.LP
Returns \fISet1\fR\&, but with \fIElement\fR\& removed\&.
.RE
.LP
.nf

.B
union(Set1, Set2) -> Set3
.br
.fi
.br
.RS
.TP 3
Types:

Set1 = Set2 = Set3 = set()
.br
.RE
.RS
.LP
Returns the merged (union) set of \fISet1\fR\& and \fISet2\fR\&\&.
.RE
.LP
.nf

.B
union(SetList) -> Set
.br
.fi
.br
.RS
.TP 3
Types:

SetList = [set()]
.br
Set = set()
.br
.RE
.RS
.LP
Returns the merged (union) set of the list of sets\&.
.RE
.LP
.nf

.B
intersection(Set1, Set2) -> Set3
.br
.fi
.br
.RS
.TP 3
Types:

Set1 = Set2 = Set3 = set()
.br
.RE
.RS
.LP
Returns the intersection of \fISet1\fR\& and \fISet2\fR\&\&.
.RE
.LP
.nf

.B
intersection(SetList) -> Set
.br
.fi
.br
.RS
.TP 3
Types:

SetList = [set(), \&.\&.\&.]
.br
Set = set()
.br
.RE
.RS
.LP
Returns the intersection of the non-empty list of sets\&.
.RE
.LP
.nf

.B
is_disjoint(Set1, Set2) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Set1 = Set2 = set()
.br
.RE
.RS
.LP
Returns \fItrue\fR\& if \fISet1\fR\& and \fISet2\fR\& are disjoint (have no elements in common), and \fIfalse\fR\& otherwise\&.
.RE
.LP
.nf

.B
subtract(Set1, Set2) -> Set3
.br
.fi
.br
.RS
.TP 3
Types:

Set1 = Set2 = Set3 = set()
.br
.RE
.RS
.LP
Returns only the elements of \fISet1\fR\& which are not also elements of \fISet2\fR\&\&.
.RE
.LP
.nf

.B
is_subset(Set1, Set2) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Set1 = Set2 = set()
.br
.RE
.RS
.LP
Returns \fItrue\fR\& when every element of \fISet1\fR\&1 is also a member of \fISet2\fR\&, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
fold(Function, Acc0, Set) -> Acc1
.br
.fi
.br
.RS
.TP 3
Types:

Function = fun((E :: term(), AccIn) -> AccOut)
.br
Set = set()
.br
Acc0 = Acc1 = AccIn = AccOut = T
.br
.RE
.RS
.LP
Fold \fIFunction\fR\& over every element in \fISet\fR\& returning the final value of the accumulator\&.
.RE
.LP
.nf

.B
filter(Pred, Set1) -> Set2
.br
.fi
.br
.RS
.TP 3
Types:

Pred = fun((E :: term()) -> boolean())
.br
Set1 = Set2 = set()
.br
.RE
.RS
.LP
Filter elements in \fISet1\fR\& with boolean function \fIPred\fR\&\&.
.RE
.SH "SEE ALSO"

.LP
\fBordsets(3)\fR\&, \fBgb_sets(3)\fR\&