.TH mod_auth 3 "inets 5.7.1" "Ericsson AB" "Erlang Module Definition"
.SH NAME
mod_auth \- User authentication using text files, dets or mnesia database.
.SH DESCRIPTION
.LP
This module provides for basic user authentication using textual files, dets databases as well as mnesia databases\&.
.SH EXPORTS
.LP
.B
add_user(UserName, Options) -> true| {error, Reason}
.br
.B
add_user(UserName, Password, UserData, Port, Dir) -> true | {error, Reason}
.br
.B
add_user(UserName, Password, UserData, Address, Port, Dir) -> true | {error, Reason}
.br
.RS
.TP 3
Types:

UserName = string()
.br
Options = [Option]
.br
Option = {password,Password} | {userData,UserData} | {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Password = string()
.br
UserData = term()
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
AuthPassword =string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIadd_user/2, add_user/5\fR\& and \fIadd_user/6\fR\& adds a user to the user database\&. If the operation is successful, this function returns \fItrue\fR\&\&. If an error occurs, \fI{error,Reason}\fR\& is returned\&. When \fIadd_user/2\fR\& is called the Password, UserData Port and Dir options is mandatory\&.
.RE
.LP
.B
delete_user(UserName,Options) -> true | {error, Reason}
.br
.B
delete_user(UserName, Port, Dir) -> true | {error, Reason}
.br
.B
delete_user(UserName, Address, Port, Dir) -> true | {error, Reason}
.br
.RS
.TP 3
Types:

UserName = string()
.br
Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
AuthPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIdelete_user/2, delete_user/3\fR\& and \fIdelete_user/4\fR\& deletes a user from the user database\&. If the operation is successful, this function returns \fItrue\fR\&\&. If an error occurs, \fI{error,Reason}\fR\& is returned\&. When \fIdelete_user/2\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
get_user(UserName,Options) -> {ok, #httpd_user} |{error, Reason}
.br
.B
get_user(UserName, Port, Dir) -> {ok, #httpd_user} | {error, Reason}
.br
.B
get_user(UserName, Address, Port, Dir) -> {ok, #httpd_user} | {error, Reason}
.br
.RS
.TP 3
Types:

UserName = string()
.br
Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
AuthPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIget_user/2, get_user/3\fR\& and \fIget_user/4\fR\& returns a \fIhttpd_user\fR\& record containing the userdata for a specific user\&. If the user cannot be found, \fI{error, Reason}\fR\& is returned\&. When \fIget_user/2\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
list_users(Options) -> {ok, Users} | {error, Reason}
.br
.B
list_users(Port, Dir) -> {ok, Users} | {error, Reason}
.br
.B
list_users(Address, Port, Dir) -> {ok, Users} | {error, Reason}
.br
.RS
.TP 3
Types:

Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
Users = list()
.br
AuthPassword = string()
.br
Reason = atom()
.br
.RE
.RS
.LP
\fIlist_users/1, list_users/2\fR\& and \fIlist_users/3\fR\& returns a list of users in the user database for a specific \fIPort/Dir\fR\&\&. When \fIlist_users/1\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
add_group_member(GroupName, UserName, Options) -> true | {error, Reason}
.br
.B
add_group_member(GroupName, UserName, Port, Dir) -> true | {error, Reason}
.br
.B
add_group_member(GroupName, UserName, Address, Port, Dir) -> true | {error, Reason}
.br
.RS
.TP 3
Types:

GroupName = string()
.br
UserName = string()
.br
Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
AuthPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIadd_group_member/3, add_group_member/4\fR\& and \fIadd_group_member/5\fR\& adds a user to a group\&. If the group does not exist, it is created and the user is added to the group\&. Upon successful operation, this function returns \fItrue\fR\&\&. When \fIadd_group_members/3\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
delete_group_member(GroupName, UserName, Options) -> true | {error, Reason}
.br
.B
delete_group_member(GroupName, UserName, Port, Dir) -> true | {error, Reason}
.br
.B
delete_group_member(GroupName, UserName, Address, Port, Dir) -> true | {error, Reason}
.br
.RS
.TP 3
Types:

GroupName = string()
.br
UserName = string()
.br
Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
AuthPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIdelete_group_member/3, delete_group_member/4\fR\& and \fIdelete_group_member/5\fR\& deletes a user from a group\&. If the group or the user does not exist, this function returns an error, otherwise it returns \fItrue\fR\&\&. When \fIdelete_group_member/3\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
list_group_members(GroupName, Options) -> {ok, Users} | {error, Reason}
.br
.B
list_group_members(GroupName, Port, Dir) -> {ok, Users} | {error, Reason}
.br
.B
list_group_members(GroupName, Address, Port, Dir) -> {ok, Users} | {error, Reason}
.br
.RS
.TP 3
Types:

GroupName = string()
.br
Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
Users = list()
.br
AuthPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIlist_group_members/2, list_group_members/3\fR\& and \fIlist_group_members/4\fR\& lists the members of a specified group\&. If the group does not exist or there is an error, \fI{error, Reason}\fR\& is returned\&. When \fIlist_group_members/2\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
list_groups(Options) -> {ok, Groups} | {error, Reason}
.br
.B
list_groups(Port, Dir) -> {ok, Groups} | {error, Reason}
.br
.B
list_groups(Address, Port, Dir) -> {ok, Groups} | {error, Reason}
.br
.RS
.TP 3
Types:

Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
Groups = list()
.br
AuthPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIlist_groups/1, list_groups/2\fR\& and \fIlist_groups/3\fR\& lists all the groups available\&. If there is an error, \fI{error, Reason}\fR\& is returned\&. When \fIlist_groups/1\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
delete_group(GroupName, Options) -> true | {error,Reason} <name>delete_group(GroupName, Port, Dir) -> true | {error, Reason}
.br
.B
delete_group(GroupName, Address, Port, Dir) -> true | {error, Reason}
.br
.RS
.TP 3
Types:

Options = [Option]
.br
Option = {port,Port} | {addr,Address} | {dir,Directory} | {authPassword,AuthPassword}
.br
Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
GroupName = string()
.br
AuthPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIdelete_group/2, delete_group/3\fR\& and \fIdelete_group/4\fR\& deletes the group specified and returns \fItrue\fR\&\&. If there is an error, \fI{error, Reason}\fR\& is returned\&. When \fIdelete_group/2\fR\& is called the Port and Dir options are mandatory\&.
.RE
.LP
.B
update_password(Port, Dir, OldPassword, NewPassword, NewPassword) -> ok | {error, Reason}
.br
.B
update_password(Address,Port, Dir, OldPassword, NewPassword, NewPassword) -> ok | {error, Reason}
.br
.RS
.TP 3
Types:

Port = integer()
.br
Address = {A,B,C,D} | string() | undefined
.br
Dir = string()
.br
GroupName = string()
.br
OldPassword = string()
.br
NewPassword = string()
.br
Reason = term()
.br
.RE
.RS
.LP
\fIupdate_password/5\fR\& and \fIupdate_password/6\fR\& Updates the AuthAccessPassword for the specified directory\&. If NewPassword is equal to "NoPassword" no password is requires to change authorisation data\&. If NewPassword is equal to "DummyPassword" no changes can be done without changing the password first\&.
.RE
.SH "SEE ALSO"

.LP
\fBhttpd(3)\fR\&, \fBmod_alias(3)\fR\&,