.TH ordsets 3 "stdlib 1.17.5" "Ericsson AB" "Erlang Module Definition"
.SH NAME
ordsets \- Functions for Manipulating Sets as Ordered Lists
.SH DESCRIPTION
.LP
Sets are collections of elements with no duplicate elements\&. An \fIordset\fR\& is a representation of a set, where an ordered list is used to store the elements of the set\&. An ordered list is more efficient than an unordered list\&.
.LP
This module provides exactly the same interface as the module \fIsets\fR\& but with a defined representation\&. One difference is that while \fIsets\fR\& considers two elements as different if they do not match (\fI=:=\fR\&), this module considers two elements as different if and only if they do not compare equal (\fI==\fR\&)\&.
.SH DATA TYPES
.nf

\fBordset(T)\fR\& = [T]
.br
.fi
.RS
.LP
As returned by new/0\&.
.RE
.SH EXPORTS
.LP
.nf

.B
new() -> []
.br
.fi
.br
.RS
.LP
Returns a new empty ordered set\&.
.RE
.LP
.nf

.B
is_set(Ordset) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Ordset = term()
.br
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOrdset\fR\& is an ordered set of elements, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
size(Ordset) -> integer() >= 0
.br
.fi
.br
.RS
.TP 3
Types:

Ordset = \fBordset\fR\&(term())
.br
.RE
.RS
.LP
Returns the number of elements in \fIOrdset\fR\&\&.
.RE
.LP
.nf

.B
to_list(Ordset) -> List
.br
.fi
.br
.RS
.TP 3
Types:

Ordset = \fBordset\fR\&(T)
.br
List = [T]
.br
.RE
.RS
.LP
Returns the elements of \fIOrdset\fR\& as a list\&.
.RE
.LP
.nf

.B
from_list(List) -> Ordset
.br
.fi
.br
.RS
.TP 3
Types:

List = [T]
.br
Ordset = \fBordset\fR\&(T)
.br
.RE
.RS
.LP
Returns an ordered set of the elements in \fIList\fR\&\&.
.RE
.LP
.nf

.B
is_element(Element, Ordset) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Element = term()
.br
Ordset = \fBordset\fR\&(term())
.br
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIElement\fR\& is an element of \fIOrdset\fR\&, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
add_element(Element, Ordset1) -> Ordset2
.br
.fi
.br
.RS
.TP 3
Types:

Element = E
.br
Ordset1 = \fBordset\fR\&(T)
.br
Ordset2 = \fBordset\fR\&(T | E)
.br
.RE
.RS
.LP
Returns a new ordered set formed from \fIOrdset1\fR\& with \fIElement\fR\& inserted\&.
.RE
.LP
.nf

.B
del_element(Element, Ordset1) -> Ordset2
.br
.fi
.br
.RS
.TP 3
Types:

Element = term()
.br
Ordset1 = Ordset2 = \fBordset\fR\&(T)
.br
.RE
.RS
.LP
Returns \fIOrdset1\fR\&, but with \fIElement\fR\& removed\&.
.RE
.LP
.nf

.B
union(Ordset1, Ordset2) -> Ordset3
.br
.fi
.br
.RS
.TP 3
Types:

Ordset1 = \fBordset\fR\&(T1)
.br
Ordset2 = \fBordset\fR\&(T2)
.br
Ordset3 = \fBordset\fR\&(T1 | T2)
.br
.RE
.RS
.LP
Returns the merged (union) set of \fIOrdset1\fR\& and \fIOrdset2\fR\&\&.
.RE
.LP
.nf

.B
union(OrdsetList) -> Ordset
.br
.fi
.br
.RS
.TP 3
Types:

OrdsetList = [\fBordset\fR\&(T)]
.br
Ordset = \fBordset\fR\&(T)
.br
.RE
.RS
.LP
Returns the merged (union) set of the list of sets\&.
.RE
.LP
.nf

.B
intersection(Ordset1, Ordset2) -> Ordset3
.br
.fi
.br
.RS
.TP 3
Types:

Ordset1 = Ordset2 = Ordset3 = \fBordset\fR\&(term())
.br
.RE
.RS
.LP
Returns the intersection of \fIOrdset1\fR\& and \fIOrdset2\fR\&\&.
.RE
.LP
.nf

.B
intersection(OrdsetList) -> Ordset
.br
.fi
.br
.RS
.TP 3
Types:

OrdsetList = [\fBordset\fR\&(term()), \&.\&.\&.]
.br
Ordset = \fBordset\fR\&(term())
.br
.RE
.RS
.LP
Returns the intersection of the non-empty list of sets\&.
.RE
.LP
.nf

.B
is_disjoint(Ordset1, Ordset2) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Ordset1 = Ordset2 = \fBordset\fR\&(term())
.br
.RE
.RS
.LP
Returns \fItrue\fR\& if \fIOrdset1\fR\& and \fIOrdset2\fR\& are disjoint (have no elements in common), and \fIfalse\fR\& otherwise\&.
.RE
.LP
.nf

.B
subtract(Ordset1, Ordset2) -> Ordset3
.br
.fi
.br
.RS
.TP 3
Types:

Ordset1 = Ordset2 = Ordset3 = \fBordset\fR\&(term())
.br
.RE
.RS
.LP
Returns only the elements of \fIOrdset1\fR\& which are not also elements of \fIOrdset2\fR\&\&.
.RE
.LP
.nf

.B
is_subset(Ordset1, Ordset2) -> boolean()
.br
.fi
.br
.RS
.TP 3
Types:

Ordset1 = Ordset2 = \fBordset\fR\&(term())
.br
.RE
.RS
.LP
Returns \fItrue\fR\& when every element of \fIOrdset1\fR\& is also a member of \fIOrdset2\fR\&, otherwise \fIfalse\fR\&\&.
.RE
.LP
.nf

.B
fold(Function, Acc0, Ordset) -> Acc1
.br
.fi
.br
.RS
.TP 3
Types:

Function = 
.br
    fun((Element :: T, AccIn :: term()) -> AccOut :: term())
.br
Ordset = \fBordset\fR\&(T)
.br
Acc0 = Acc1 = term()
.br
.RE
.RS
.LP
Fold \fIFunction\fR\& over every element in \fIOrdset\fR\& returning the final value of the accumulator\&.
.RE
.LP
.nf

.B
filter(Pred, Ordset1) -> Ordset2
.br
.fi
.br
.RS
.TP 3
Types:

Pred = fun((Element :: T) -> boolean())
.br
Ordset1 = Ordset2 = \fBordset\fR\&(T)
.br
.RE
.RS
.LP
Filter elements in \fIOrdset1\fR\& with boolean function \fIPred\fR\&\&.
.RE
.SH "SEE ALSO"

.LP
\fBgb_sets(3)\fR\&, \fBsets(3)\fR\&