.TH erl_ddll 3 "kernel 2.14.5" "Ericsson AB" "Erlang Module Definition"
.SH NAME
erl_ddll \- Dynamic Driver Loader and Linker
.SH DESCRIPTION
.LP
The \fIerl_ddll\fR\& module provides an interface for loading and unloading \fIerlang linked in drivers\fR\& in runtime\&.
.LP

.RS -4
.B
Note:
.RE
This is a large reference document\&. For casual use of the module, as well as for most real world applications, the descriptions of the functions \fBload/2\fR\& and \fBunload/1\fR\& are enough to get going\&.

.LP
The driver should be provided as a dynamically linked library in a object code format specific for the platform in use, i\&. e\&. \fI\&.so\fR\& files on most Unix systems and \fI\&.ddl\fR\& files on windows\&. An erlang linked in driver has to provide specific interfaces to the emulator, so this module is not designed for loading arbitrary dynamic libraries\&. For further information about erlang drivers, refer to the ERTS reference manual section \fBerl_driver\fR\&\&.
.LP
When describing a set of functions, (i\&.e\&. a module, a part of a module or an application) executing in a process and wanting to use a ddll-driver, we use the term \fIuser\fR\&\&. There can be several users in one process (different modules needing the same driver) and several processes running the same code, making up several \fIusers\fR\& of a driver\&. In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done\&. The reference counting keeps track of processes as well as the number of loads by each process, so that the driver will only be unloaded when no one wants it (it has no user)\&. The driver also keeps track of ports that are opened towards it, so that one can delay unloading until all ports are closed or kill all ports using the driver when it is unloaded\&.
.LP
The interface supports two basic scenarios of loading and unloading\&. Each scenario can also have the option of either killing ports when the driver is unloading, or waiting for the ports to close themselves\&. The scenarios are:
.RS 2
.TP 2
.B
\fILoad and unload on a "when needed basis"\fR\&:
This (most common) scenario simply supports that each \fBuser\fR\& of the driver loads it when it is needed and unloads it when the \fBuser\fR\& no longer have any use for it\&. The driver is always reference counted and as long as a process keeping the driver loaded is still alive, the driver is present in the system\&.
.RS 2
.LP
Each \fBuser\fR\& of the driver use \fIliterally\fR\& the same pathname for the driver when demanding load, but the \fBusers\fR\& are not really concerned with if the driver is already loaded from the filesystem or if the object code has to be loaded from filesystem\&.
.RE
.RS 2
.LP
Two pairs of functions support this scenario:
.RE
.RS 2
.TP 2
.B
\fIload/2 and unload/1\fR\&:
When using the \fIload/unload\fR\& interfaces, the driver will not \fIactually\fR\& get unloaded until the \fIlast port\fR\& using the driver is closed\&. The function \fIunload/1\fR\& can return immediately, as the \fBusers\fR\& are not really concerned with when the actual unloading occurs\&. The driver will actually get unloaded when no one needs it any longer\&.
.RS 2
.LP
If a process having the driver loaded dies, it will have the same effect as if unloading was done\&.
.RE
.RS 2
.LP
When loading, the function \fIload/2\fR\& returns \fIok\fR\& as soon as there is any instance of the driver present, so that if a driver is waiting to get unloaded (due to open ports), it will simply change state to no longer need unloading\&.
.RE
.TP 2
.B
\fIload_driver/2 and unload_driver/1\fR\&:
These interfaces is intended to be used when it is considered an error that ports are open towards a driver that no \fBuser\fR\& has loaded\&. The ports still open when the last \fBuser\fR\& calls \fIunload_driver/1\fR\& or when the last process having the driver loaded dies, will get killed with reason \fIdriver_unloaded\fR\&\&.
.RS 2
.LP
The function names \fIload_driver\fR\& and \fIunload_driver\fR\& are kept for backward compatibility\&.
.RE
.RE
.TP 2
.B
\fILoading and reloading for code replacement\fR\&:
This scenario occurs when the driver code might need replacement during operation of the Erlang emulator\&. Implementing driver code replacement is somewhat more tedious than beam code replacement, as one driver cannot be loaded as both "old" and "new" code\&. All \fBusers\fR\& of a driver must have it closed (no open ports) before the old code can be unloaded and the new code can be loaded\&.
.RS 2
.LP
The actual unloading/loading is done as one atomic operation, blocking all processes in the system from using the driver concerned while in progress\&.
.RE
.RS 2
.LP
The preferred way to do driver code replacement is to let \fIone single process\fR\& keep track of the driver\&. When the process start, the driver is loaded\&. When replacement is required, the driver is reloaded\&. Unload is probably never done, or done when the process exits\&. If more than one \fBuser\fR\& has a driver loaded when code replacement is demanded, the replacement cannot occur until the last "other" \fBuser\fR\& has unloaded the driver\&.
.RE
.RS 2
.LP
Demanding reload when a reload is already in progress is always an error\&. Using the high level functions, it is also an error to demand reloading when more than one \fBuser\fR\& has the driver loaded\&. To simplify driver replacement, avoid designing your system so that more than than one \fBuser\fR\& has the driver loaded\&.
.RE
.RS 2
.LP
The two functions for reloading drivers should be used together with corresponding load functions, to support the two different behaviors concerning open ports:
.RE
.RS 2
.TP 2
.B
\fIload/2 and reload/2\fR\&:
This pair of functions is used when reloading should be done after the last open port towards the driver is closed\&.
.RS 2
.LP
As \fIreload/2\fR\& actually waits for the reloading to occur, a misbehaving process keeping open ports towards the driver (or keeping the driver loaded) might cause infinite waiting for reload\&. Timeouts has to be provided outside of the process demanding the reload or by using the low-level interface \fBtry_load/3\fR\& in combination with driver monitors (see below)\&.
.RE
.TP 2
.B
\fIload_driver/2 and reload_driver/2\fR\&:
This pair of functions are used when open ports towards the driver should be killed with reason \fIdriver_unloaded\fR\& to allow for new driver code to get loaded\&.
.RS 2
.LP
If, however, another process has the driver loaded, calling \fIreload_driver\fR\& returns the error code \fIpending_process\fR\&\&. As stated earlier, the recommended design is to not allow other \fBusers\fR\& than the "driver reloader" to actually demand loading of the concerned driver\&.
.RE
.RE
.RE
.SH DATA TYPES
.nf

\fBdriver()\fR\& = string() | atom()
.br
.fi
.nf

\fBpath()\fR\& = string() | atom()
.br
.fi
.SH EXPORTS
.LP
.B
demonitor(MonitorRef) -> ok
.br
.RS
.TP 3
Types:

MonitorRef = reference()
.br
.RE
.RS
.LP
Removes a driver monitor in much the same way as \fBerlang:demonitor/1\fR\& does with process monitors\&. See \fBmonitor/2\fR\&, \fBtry_load/3\fR\& and \fBtry_unload/2\fR\& for details about how to create driver monitors\&.
.LP
The function throws a \fIbadarg\fR\& exception if the parameter is not a reference()\&.
.RE
.LP
.nf

.B
info() -> AllInfoList
.br
.fi
.br
.RS
.TP 3
Types:

AllInfoList = [DriverInfo]
.br
DriverInfo = {DriverName, InfoList}
.br
DriverName = string()
.br
InfoList = [InfoItem]
.br
InfoItem = {Tag :: atom(), Value :: term()}
.br
.RE
.RS
.LP
Returns a list of tuples \fI{DriverName, InfoList}\fR\&, where \fIInfoList\fR\& is the result of calling \fBinfo/1\fR\& for that \fIDriverName\fR\&\&. Only dynamically linked in drivers are included in the list\&.
.RE
.LP
.nf

.B
info(Name) -> InfoList
.br
.fi
.br
.RS
.TP 3
Types:

Name = \fBdriver()\fR\&
.br
InfoList = [InfoItem, \&.\&.\&.]
.br
InfoItem = {Tag :: atom(), Value :: term()}
.br
.RE
.RS
.LP
Returns a list of tuples \fI{Tag, Value}\fR\&, where \fITag\fR\& is the information item and \fIValue\fR\& is the result of calling \fBinfo/2\fR\& with this driver name and this tag\&. The result being a tuple list containing all information available about a driver\&.
.LP
The different tags that will appear in the list are:
.RS 2
.TP 2
*
processes
.LP
.TP 2
*
driver_options
.LP
.TP 2
*
port_count
.LP
.TP 2
*
linked_in_driver
.LP
.TP 2
*
permanent
.LP
.TP 2
*
awaiting_load
.LP
.TP 2
*
awaiting_unload
.LP
.RE

.LP
For a detailed description of each value, please read the description of \fBinfo/2\fR\& below\&.
.LP
The function throws a \fIbadarg\fR\& exception if the driver is not present in the system\&.
.RE
.LP
.B
info(Name, Tag) -> Value
.br
.RS
.TP 3
Types:

Name = string() | atom()
.br
Tag = processes | driver_options | port_count | linked_in_driver | permanent | awaiting_load | awaiting_unload
.br
Value = term()
.br
.RE
.RS
.LP
This function returns specific information about one aspect of a driver\&. The \fITag\fR\& parameter specifies which aspect to get information about\&. The \fIValue\fR\& return differs between different tags:
.RS 2
.TP 2
.B
\fIprocesses\fR\&:
Return all processes containing \fBusers\fR\& of the specific drivers as a list of tuples \fI{pid(),int()}\fR\&, where the \fIint()\fR\& denotes the number of users in the process \fIpid()\fR\&\&.
.TP 2
.B
\fIdriver_options\fR\&:
Return a list of the driver options provided when loading, as well as any options set by the driver itself during initialization\&. The currently only valid option being \fIkill_ports\fR\&\&.
.TP 2
.B
\fIport_count\fR\&:
Return the number of ports (an \fIint()\fR\&) using the driver\&.
.TP 2
.B
\fIlinked_in_driver\fR\&:
Return a \fIbool()\fR\&, being \fItrue\fR\& if the driver is a statically linked in one and \fIfalse\fR\& otherwise\&.
.TP 2
.B
\fIpermanent\fR\&:
Return a \fIbool()\fR\&, being \fItrue\fR\& if the driver has made itself permanent (and is \fInot\fR\& a statically linked in driver)\&. \fIfalse\fR\& otherwise\&.
.TP 2
.B
\fIawaiting_load\fR\&:
Return a list of all processes having monitors for \fIloading\fR\& active, each process returned as \fI{pid(),int()}\fR\&, where the \fIint()\fR\& is the number of monitors held by the process \fIpid()\fR\&\&.
.TP 2
.B
\fIawaiting_unload\fR\&:
Return a list of all processes having monitors for \fIunloading\fR\& active, each process returned as \fI{pid(),int()}\fR\&, where the \fIint()\fR\& is the number of monitors held by the process \fIpid()\fR\&\&.
.RE
.LP
If the options \fIlinked_in_driver\fR\& or \fIpermanent\fR\& return true, all other options will return the value \fIlinked_in_driver\fR\& or \fIpermanent\fR\& respectively\&.
.LP
The function throws a \fIbadarg\fR\& exception if the driver is not present in the system or the tag is not supported\&.
.RE
.LP
.nf

.B
load(Path, Name) -> ok | {error, ErrorDesc}
.br
.fi
.br
.RS
.TP 3
Types:

Path = \fBpath()\fR\&
.br
Name = \fBdriver()\fR\&
.br
ErrorDesc = term()
.br
.RE
.RS
.LP
Loads and links the dynamic driver \fIName\fR\&\&. \fIPath\fR\& is a file path to the directory containing the driver\&. \fIName\fR\& must be a sharable object/dynamic library\&. Two drivers with different \fIPath\fR\& parameters cannot be loaded under the same name\&. The \fIName\fR\& is a string or atom containing at least one character\&.
.LP
The \fIName\fR\& given should correspond to the filename of the actual dynamically loadable object file residing in the directory given as \fIPath\fR\&, but \fIwithout\fR\& the extension (i\&.e\&. \fI\&.so\fR\&)\&. The driver name provided in the driver initialization routine must correspond with the filename, in much the same way as erlang module names correspond to the names of the \fI\&.beam\fR\& files\&.
.LP
If the driver has been previously unloaded, but is still present due to open ports against it, a call to \fIload/2\fR\& will stop the unloading and keep the driver (as long as the \fIPath\fR\& is the same) and \fIok\fR\& is returned\&. If one actually wants the object code to be reloaded, one uses \fBreload/2\fR\& or the low-level interface \fBtry_load/3\fR\& instead\&. Please refer to the description of \fBdifferent scenarios\fR\& for loading/unloading in the introduction\&.
.LP
If more than one process tries to load an already loaded driver withe the same \fIPath\fR\&, or if the same process tries to load it several times, the function will return \fIok\fR\&\&. The emulator will keep track of the \fIload/2\fR\& calls, so that a corresponding number of \fIunload/2\fR\& calls will have to be done from the same process before the driver will actually get unloaded\&. It is therefore safe for an application to load a driver that is shared between processes or applications when needed\&. It can safely be unloaded without causing trouble for other parts of the system\&.
.LP
It is not allowed to load several drivers with the same name but with different \fIPath\fR\& parameters\&.
.LP

.RS -4
.B
Note:
.RE
Note especially that the \fIPath\fR\& is interpreted literally, so that all loaders of the same driver needs to give the same \fIliteral\fR\&\fIPath\fR\& string, even though different paths might point out the same directory in the filesystem (due to use of relative paths and links)\&.

.LP
On success, the function returns \fIok\fR\&\&. On failure, the return value is \fI{error,ErrorDesc}\fR\&, where \fIErrorDesc\fR\& is an opaque term to be translated into human readable form by the \fBformat_error/1\fR\& function\&.
.LP
For more control over the error handling, again use the \fBtry_load/3\fR\& interface instead\&.
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.nf

.B
load_driver(Path, Name) -> ok | {error, ErrorDesc}
.br
.fi
.br
.RS
.TP 3
Types:

Path = \fBpath()\fR\&
.br
Name = \fBdriver()\fR\&
.br
ErrorDesc = term()
.br
.RE
.RS
.LP
Works essentially as \fIload/2\fR\&, but will load the driver with other options\&. All ports that are using the driver will get killed with the reason \fIdriver_unloaded\fR\& when the driver is to be unloaded\&.
.LP
The number of loads and unloads by different \fBusers\fR\& influence the actual loading and unloading of a driver file\&. The port killing will therefore only happen when the \fIlast\fR\& \fBuser\fR\& unloads the driver, or the last process having loaded the driver exits\&.
.LP
This interface (or at least the name of the functions) is kept for backward compatibility\&. Using \fBtry_load/3\fR\& with \fI{driver_options,[kill_ports]} \fR\& in the option list will give the same effect regarding the port killing\&.
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.B
monitor(Tag, Item) -> MonitorRef
.br
.RS
.TP 3
Types:

Tag = driver
.br
Item = {Name, When}
.br
Name = atom() | string()
.br
When = loaded | unloaded | unloaded_only
.br
MonitorRef = reference()
.br
.RE
.RS
.LP
This function creates a driver monitor and works in many ways as the function \fBerlang:monitor/2\fR\&, does for processes\&. When a driver changes state, the monitor results in a monitor-message being sent to the calling process\&. The \fIMonitorRef\fR\& returned by this function is included in the message sent\&.
.LP
As with process monitors, each driver monitor set will only generate \fIone single message\fR\&\&. The monitor is "destroyed" after the message is sent and there is then no need to call \fBdemonitor/1\fR\&\&.
.LP
The \fIMonitorRef\fR\& can also be used in subsequent calls to \fBdemonitor/1\fR\& to remove a monitor\&.
.LP
The function accepts the following parameters:
.RS 2
.TP 2
.B
\fITag\fR\&:
The monitor tag is always \fIdriver\fR\& as this function can only be used to create driver monitors\&. In the future, driver monitors will be integrated with process monitors, why this parameter has to be given for consistence\&.
.TP 2
.B
\fIItem\fR\&:
The \fIItem\fR\& parameter specifies which driver one wants to monitor (the name of the driver) as well as which state change one wants to monitor\&. The parameter is a tuple of arity two whose first element is the driver name and second element is either of:
.RS 2
.TP 2
.B
\fIloaded\fR\&:
Notify me when the driver is reloaded (or loaded if loading is underway)\&. It only makes sense to monitor drivers that are in the process of being loaded or reloaded\&. One cannot monitor a future-to-be driver name for loading, that will only result in a \fI\&'DOWN\&'\fR\& message being immediately sent\&. Monitoring for loading is therefore most useful when triggered by the \fBtry_load/3\fR\& function, where the monitor is created \fIbecause\fR\& the driver is in such a pending state\&.
.RS 2
.LP
Setting a driver monitor for \fIloading\fR\& will eventually lead to one of the following messages being sent:
.RE
.RS 2
.TP 2
.B
\fI{\&'UP\&', reference(), driver, Name, loaded}\fR\&:
This message is sent, either immediately if the driver is already loaded and no reloading is pending, or when reloading is executed if reloading is pending\&.
.RS 2
.LP
The \fBuser\fR\& is expected to know if reloading is demanded prior to creating a monitor for loading\&.
.RE
.TP 2
.B
\fI{\&'UP\&', reference(), driver, Name, permanent}\fR\&:
This message will be sent if reloading was expected, but the (old) driver made itself permanent prior to reloading\&. It will also be sent if the driver was permanent or statically linked in when trying to create the monitor\&.
.TP 2
.B
\fI{\&'DOWN\&', reference(), driver, Name, load_cancelled}\fR\&:
This message will arrive if reloading was underway, but the \fBuser\fR\& having requested reload cancelled it by either dying or calling \fBtry_unload/2\fR\& (or \fIunload/1\fR\&/\fIunload_driver/1\fR\&) again before it was reloaded\&.
.TP 2
.B
\fI{\&'DOWN\&', reference(), driver, Name, {load_failure, Failure}}\fR\&:
This message will arrive if reloading was underway but the loading for some reason failed\&. The \fIFailure\fR\& term is one of the errors that can be returned from \fBtry_load/3\fR\&\&. The error term can be passed to \fBformat_error/1\fR\& for translation into human readable form\&. Note that the translation has to be done in the same running erlang virtual machine as the error was detected in\&.
.RE
.TP 2
.B
\fIunloaded\fR\&:
Monitor when a driver gets unloaded\&. If one monitors a driver that is not present in the system, one will immediately get notified that the driver got unloaded\&. There is no guarantee that the driver was actually ever loaded\&.
.RS 2
.LP
A driver monitor for unload will eventually result in one of the following messages being sent:
.RE
.RS 2
.TP 2
.B
\fI{\&'DOWN\&', reference(), driver, Name, unloaded}\fR\&:
The driver instance monitored is now unloaded\&. As the unload might have been due to a \fIreload/2\fR\& request, the driver might once again have been loaded when this message arrives\&.
.TP 2
.B
\fI{\&'UP\&', reference(), driver, Name, unload_cancelled}\fR\&:
This message will be sent if unloading was expected, but while the driver was waiting for all ports to get closed, a new \fBuser\fR\& of the driver appeared and the unloading was cancelled\&.
.RS 2
.LP
This message appears when an \fI{ok, pending_driver}\fR\&) was returned from \fBtry_unload/2\fR\&) for the last \fBuser\fR\& of the driver and then a \fI{ok, already_loaded}\fR\& is returned from a call to \fBtry_load/3\fR\&\&.
.RE
.RS 2
.LP
If one wants to \fIreally\fR\& monitor when the driver gets unloaded, this message will distort the picture, no unloading was really done\&. The \fIunloaded_only\fR\& option creates a monitor similar to an \fIunloaded\fR\& monitor, but does never result in this message\&.
.RE
.TP 2
.B
\fI{\&'UP\&', reference(), driver, Name, permanent}\fR\&:
This message will be sent if unloading was expected, but the driver made itself permanent prior to unloading\&. It will also be sent if trying to monitor a permanent or statically linked in driver\&.
.RE
.TP 2
.B
\fIunloaded_only\fR\&:
A monitor created as \fIunloaded_only\fR\& behaves exactly as one created as \fIunloaded\fR\& with the exception that the \fI{\&'UP\&', reference(), driver, Name, unload_cancelled}\fR\& message will never be sent, but the monitor instead persists until the driver \fIreally\fR\& gets unloaded\&.
.RE
.RE
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.nf

.B
reload(Path, Name) -> ok | {error, ErrorDesc}
.br
.fi
.br
.RS
.TP 3
Types:

Path = \fBpath()\fR\&
.br
Name = \fBdriver()\fR\&
.br
ErrorDesc = pending_process | OpaqueError
.br
OpaqueError = term()
.br
.RE
.RS
.LP
Reloads the driver named \fIName\fR\& from a possibly different \fIPath\fR\& than was previously used\&. This function is used in the code change \fBscenario\fR\& described in the introduction\&.
.LP
If there are other \fBusers\fR\& of this driver, the function will return \fI{error, pending_process}\fR\&, but if there are no more users, the function call will hang until all open ports are closed\&.
.LP

.RS -4
.B
Note:
.RE
Avoid mixing several \fBusers\fR\& with driver reload requests\&.

.LP
If one wants to avoid hanging on open ports, one should use the \fBtry_load/3\fR\& function instead\&.
.LP
The \fIName\fR\& and \fIPath\fR\& parameters have exactly the same meaning as when calling the plain \fBload/2\fR\& function\&.
.LP

.RS -4
.B
Note:
.RE
Avoid mixing several \fBusers\fR\& with driver reload requests\&.

.LP
On success, the function returns \fIok\fR\&\&. On failure, the function returns an opaque error, with the exception of the \fIpending_process\fR\& error described above\&. The opaque errors are to be translated into human readable form by the \fBformat_error/1\fR\& function\&.
.LP
For more control over the error handling, again use the \fBtry_load/3\fR\& interface instead\&.
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.nf

.B
reload_driver(Path, Name) -> ok | {error, ErrorDesc}
.br
.fi
.br
.RS
.TP 3
Types:

Path = \fBpath()\fR\&
.br
Name = \fBdriver()\fR\&
.br
ErrorDesc = pending_process | OpaqueError
.br
OpaqueError = term()
.br
.RE
.RS
.LP
Works exactly as \fBreload/2\fR\&, but for drivers loaded with the \fBload_driver/2\fR\& interface\&.
.LP
As this interface implies that ports are being killed when the last user disappears, the function wont hang waiting for ports to get closed\&.
.LP
For further details, see the \fBscenarios\fR\& in the module description and refer to the \fBreload/2\fR\& function description\&.
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.B
try_load(Path, Name, OptionList) -> {ok,Status} | {ok, PendingStatus, Ref} | {error, ErrorDesc}
.br
.RS
.TP 3
Types:

Path = Name = string() | atom()
.br
OptionList = [ Option ]
.br
Option = {driver_options, DriverOptionList} | {monitor, MonitorOption} | {reload, ReloadOption}
.br
DriverOptionList = [ DriverOption ]
.br
DriverOption = kill_ports
.br
MonitorOption = pending_driver | pending
.br
ReloadOption = pending_driver | pending
.br
Status = loaded | already_loaded | PendingStatus
.br
PendingStatus = pending_driver | pending_process
.br
Ref = reference()
.br
ErrorDesc = ErrorAtom | OpaqueError
.br
ErrorAtom = linked_in_driver | inconsistent | permanent | not_loaded_by_this_process | not_loaded | pending_reload | pending_process
.br
.RE
.RS
.LP
This function provides more control than the \fIload/2\fR\&/\fIreload/2\fR\& and \fIload_driver/2\fR\&/\fIreload_driver/2\fR\& interfaces\&. It will never wait for completion of other operations related to the driver, but immediately return the status of the driver as either:
.RS 2
.TP 2
.B
\fI{ok, loaded}\fR\&:
The driver was actually loaded and is immediately usable\&.
.TP 2
.B
\fI{ok, already_loaded}\fR\&:
The driver was already loaded by another process and/or is in use by a living port\&. The load by you is registered and a corresponding \fItry_unload\fR\& is expected sometime in the future\&.
.TP 2
.B
\fI{ok, pending_driver}\fR\&or \fI{ok, pending_driver, reference()}\fR\&:
The load request is registered, but the loading is delayed due to the fact that an earlier instance of the driver is still waiting to get unloaded (there are open ports using it)\&. Still, unload is expected when you are done with the driver\&. This return value will \fImostly\fR\& happen when the \fI{reload,pending_driver}\fR\& or \fI{reload,pending}\fR\& options are used, but \fIcan\fR\& happen when another \fBuser\fR\& is unloading a driver in parallel and the \fIkill_ports\fR\& driver option is set\&. In other words, this return value will always need to be handled!
.TP 2
.B
\fI{ok, pending_process}\fR\&or \fI{ok, pending_process, reference()}\fR\&:
The load request is registered, but the loading is delayed due to the fact that an earlier instance of the driver is still waiting to get unloaded by another \fBuser\fR\& (not only by a port, in which case \fI{ok,pending_driver}\fR\& would have been returned)\&. Still, unload is expected when you are done with the driver\&. This return value will \fIonly\fR\& happen when the \fI{reload,pending}\fR\& option is used\&.
.RE
.LP
When the function returns \fI{ok, pending_driver}\fR\& or \fI{ok, pending_process}\fR\&, one might want to get information about when the driver is \fIactually\fR\& loaded\&. This can be achieved by using the \fI{monitor, PendingOption}\fR\& option\&.
.LP
When monitoring is requested, and a corresponding \fI{ok, pending_driver}\fR\& or \fI{ok, pending_process}\fR\& would be returned, the function will instead return a tuple \fI{ok, PendingStatus, reference()}\fR\& and the process will, at a later time when the driver actually gets loaded, get a monitor message\&. The monitor message one can expect is described in the \fBmonitor/2\fR\& function description\&.
.LP

.RS -4
.B
Note:
.RE
Note that in case of loading, monitoring can \fInot\fR\& only get triggered by using the \fI{reload, ReloadOption}\fR\& option, but also in special cases where the load-error is transient, why \fI{monitor, pending_driver}\fR\& should be used under basically \fIall\fR\& real world circumstances!

.LP
The function accepts the following parameters:
.RS 2
.TP 2
.B
\fIPath\fR\&:
The filesystem path to the directory where the driver object file is situated\&. The filename of the object file (minus extension) must correspond to the driver name (used in the name parameter) and the driver must identify itself with the very same name\&. The \fIPath\fR\& might be provided as an \fIio_list\fR\&, meaning it can be a list of other io_lists, characters (eight bit integers) or binaries, all to be flattened into a sequence of characters\&.
.RS 2
.LP
The (possibly flattened) \fIPath\fR\& parameter must be consistent throughout the system, a driver should, by all \fBusers\fR\&, be loaded using the same \fIliteral\fR\&\fIPath\fR\&\&. The exception is when \fIreloading\fR\& is requested, in which case the \fIPath\fR\& may be specified differently\&. Note that all \fBusers\fR\& trying to load the driver at a later time will need to use the \fInew\fR\&\fIPath\fR\& if the \fIPath\fR\& is changed using a \fIreload\fR\& option\&. This is yet another reason to have \fIonly one loader\fR\& of a driver one wants to upgrade in a running system!
.RE
.TP 2
.B
\fIName\fR\&:
The name parameter is the name of the driver to be used in subsequent calls to \fBopen_port\fR\&\&. The name can be specified either as an \fIio_list()\fR\& or as an \fIatom()\fR\&\&. The name given when loading is used to find the actual object file (with the help of the \fIPath\fR\& and the system implied extension suffix, i\&.e\&. \fI\&.so\fR\&)\&. The name by which the driver identifies itself must also be consistent with this \fIName\fR\& parameter, much as a beam-file\&'s module name much correspond to its filename\&.
.TP 2
.B
\fIOptionList\fR\&:
A number of options can be specified to control the loading operation\&. The options are given as a list of two-tuples, the tuples having the following values and meanings:
.RS 2
.TP 2
.B
\fI{driver_options, DriverOptionsList}\fR\&:
This option is to provide options that will change its general behavior and will "stick" to the driver throughout its lifespan\&.
.RS 2
.LP
The driver options for a given driver name need always to be consistent, \fIeven when the driver is reloaded\fR\&, meaning that they are as much a part of the driver as the actual name\&.
.RE
.RS 2
.LP
Currently the only allowed driver option is \fIkill_ports\fR\&, which means that all ports opened towards the driver are killed with the exit-reason \fIdriver_unloaded\fR\& when no process any longer has the driver loaded\&. This situation arises either when the last \fBuser\fR\& calls \fBtry_unload/2\fR\&, or the last process having loaded the driver exits\&.
.RE
.TP 2
.B
\fI{monitor, MonitorOption}\fR\&:
A \fIMonitorOption\fR\& tells \fItry_load/3\fR\& to trigger a driver monitor under certain conditions\&. When the monitor is triggered, the function will return a three-tuple \fI{ok, PendingStatus, reference()}\fR\&, where the \fIreference()\fR\& is the monitor ref for the driver monitor\&.
.RS 2
.LP
Only one \fIMonitorOption\fR\& can be specified and it is either the atom \fIpending\fR\&, which means that a monitor should be created whenever a load operation is delayed, and the atom \fIpending_driver\fR\&, in which a monitor is created whenever the operation is delayed due to open ports towards an otherwise unused driver\&. The \fIpending_driver\fR\& option is of little use, but is present for completeness, it is very well defined which reload-options might give rise to which delays\&. It might, however, be a good idea to use the same \fIMonitorOption\fR\& as the \fIReloadOption\fR\& if present\&.
.RE
.RS 2
.LP
If reloading is not requested, it might still be useful to specify the \fImonitor\fR\& option, as forced unloads (\fIkill_ports\fR\& driver option or the \fIkill_ports\fR\& option to \fBtry_unload/2\fR\&) will trigger a transient state where driver loading cannot be performed until all closing ports are actually closed\&. So, as \fItry_unload\fR\& can, in almost all situations, return \fI{ok, pending_driver}\fR\&, one should always specify at least \fI{monitor, pending_driver}\fR\& in production code (see the monitor discussion above)\&.
.RE
.TP 2
.B
\fI{reload,RealoadOption}\fR\&:
This option is used when one wants to \fIreload\fR\& a driver from disk, most often in a code upgrade scenario\&. Having a \fIreload\fR\& option also implies that the \fIPath\fR\& parameter need \fInot\fR\& be consistent with earlier loads of the driver\&.
.RS 2
.LP
To reload a driver, the process needs to have previously loaded the driver, i\&.e there has to be an active \fBuser\fR\& of the driver in the process\&.
.RE
.RS 2
.LP
The \fIreload\fR\& option can be either the atom \fIpending\fR\&, in which reloading is requested for any driver and will be effectuated when \fIall\fR\& ports opened against the driver are closed\&. The replacement of the driver will in this case take place regardless of if there are still pending \fBusers\fR\& having the driver loaded! The option also triggers port-killing (if the \fIkill_ports\fR\& driver option is used) even though there are pending users, making it usable for forced driver replacement, but laying a lot of responsibility on the driver \fBusers\fR\&\&. The pending option is seldom used as one does not want other \fBusers\fR\& to have loaded the driver when code change is underway\&.
.RE
.RS 2
.LP
The more useful option is \fIpending_driver\fR\&, which means that reloading will be queued if the driver is \fInot\fR\& loaded by any other \fBusers\fR\&, but the driver has opened ports, in which case \fI{ok, pending_driver}\fR\& will be returned (a \fImonitor\fR\& option is of course recommended)\&.
.RE
.RS 2
.LP
If the driver is unloaded (not present in the system), the error code \fInot_loaded\fR\& will be returned\&. The \fIreload\fR\& option is intended for when the user has already loaded the driver in advance\&.
.RE
.RE
.RE
.LP
The function might return numerous errors, of which some only can be returned given a certain combination of options\&.
.LP
A number of errors are opaque and can only be interpreted by passing them to the \fBformat_error/1\fR\& function, but some can be interpreted directly:
.RS 2
.TP 2
.B
\fI{error,linked_in_driver}\fR\&:
The driver with the specified name is an erlang statically linked in driver, which cannot be manipulated with this API\&.
.TP 2
.B
\fI{error,inconsistent}\fR\&:
The driver has already been loaded with either other \fIDriverOptions\fR\& or a different \fIliteral\fR\&\fIPath\fR\& argument\&.
.RS 2
.LP
This can happen even if a \fIreload\fR\& option is given, if the \fIDriverOptions\fR\& differ from the current\&.
.RE
.TP 2
.B
\fI{error, permanent}\fR\&:
The driver has requested itself to be permanent, making it behave like an erlang linked in driver and it can no longer be manipulated with this API\&.
.TP 2
.B
\fI{error, pending_process}\fR\&:
The driver is loaded by other \fBusers\fR\& when the \fI{reload, pending_driver}\fR\& option was given\&.
.TP 2
.B
\fI{error, pending_reload}\fR\&:
Driver reload is already requested by another \fBuser\fR\& when the \fI{reload, ReloadOption}\fR\& option was given\&.
.TP 2
.B
\fI{error, not_loaded_by_this_process}\fR\&:
Appears when the \fIreload\fR\& option is given\&. The driver \fIName\fR\& is present in the system, but there is no \fBuser\fR\& of it in this process\&.
.TP 2
.B
\fI{error, not_loaded}\fR\&:
Appears when the \fIreload\fR\& option is given\&. The driver \fIName\fR\& is not in the system\&. Only drivers loaded by this process can be reloaded\&.
.RE
.LP
All other error codes are to be translated by the \fBformat_error/1\fR\& function\&. Note that calls to \fIformat_error\fR\& should be performed from the same running instance of the erlang virtual machine as the error was detected in, due to system dependent behavior concerning error values\&.
.LP
If the arguments or options are malformed, the function will throw a \fIbadarg\fR\& exception\&.
.RE
.LP
.B
try_unload(Name, OptionList) -> {ok,Status} | {ok, PendingStatus, Ref} | {error, ErrorAtom}
.br
.RS
.TP 3
Types:

Name = string() | atom()
.br
OptionList = [ Option ]
.br
Option = {monitor, MonitorOption} | kill_ports
.br
MonitorOption = pending_driver | pending
.br
Status = unloaded | PendingStatus
.br
PendingStatus = pending_driver | pending_process
.br
Ref = reference()
.br
ErrorAtom = linked_in_driver | not_loaded | not_loaded_by_this_process | permanent
.br
.RE
.RS
.LP
This is the low level function to unload (or decrement reference counts of) a driver\&. It can be used to force port killing, in much the same way as the driver option \fIkill_ports\fR\& implicitly does, and it can trigger a monitor either due to other \fBusers\fR\& still having the driver loaded or that there are open ports using the driver\&.
.LP
Unloading can be described as the process of telling the emulator that this particular part of the code in this particular process (i\&.e\&. this \fBuser\fR\&) no longer needs the driver\&. That can, if there are no other users, trigger actual unloading of the driver, in which case the driver name disappears from the system and (if possible) the memory occupied by the driver executable code is reclaimed\&. If the driver has the \fIkill_ports\fR\& option set, or if \fIkill_ports\fR\& was specified as an option to this function, all pending ports using this driver will get killed when unloading is done by the last \fBuser\fR\&\&. If no port-killing is involved and there are open ports, the actual unloading is delayed until there are no more open ports using the driver\&. If, in this case, another \fBuser\fR\& (or even this user) loads the driver again before the driver is actually unloaded, the unloading will never take place\&.
.LP
To allow the \fBuser\fR\& that \fIrequests unloading\fR\& to wait for \fIactual unloading\fR\& to take place, \fImonitor\fR\& triggers can be specified in much the same way as when loading\&. As \fBusers\fR\& of this function however seldom are interested in more than decrementing the reference counts, monitoring is more seldom needed\&. If the \fIkill_ports\fR\& option is used however, monitor trigging is crucial, as the ports are not guaranteed to have been killed until the driver is unloaded, why a monitor should be triggered for at least the \fIpending_driver\fR\& case\&.
.LP
The possible monitor messages that can be expected are the same as when using the \fIunloaded\fR\& option to the \fBmonitor/2\fR\& function\&.
.LP
The function will return one of the following statuses upon success:
.RS 2
.TP 2
.B
\fI{ok, unloaded}\fR\&:
The driver was immediately unloaded, meaning that the driver name is now free to use by other drivers and, if the underlying OS permits it, the memory occupied by the driver object code is now reclaimed\&.
.RS 2
.LP
The driver can only be unloaded when there are no open ports using it and there are no more \fBusers\fR\& requiring it to be loaded\&.
.RE
.TP 2
.B
\fI{ok, pending_driver}\fR\&or \fI{ok, pending_driver, reference()}\fR\&:
This return value indicates that this call removed the last \fBuser\fR\& from the driver, but there are still open ports using it\&. When all ports are closed and no new \fBusers\fR\& have arrived, the driver will actually be reloaded and the name and memory reclaimed\&.
.RS 2
.LP
This return value is valid even when the option \fIkill_ports\fR\& was used, as killing ports may not be a process that completes immediately\&. The condition is, in that case, however transient\&. Monitors are as always useful to detect when the driver is really unloaded\&.
.RE
.TP 2
.B
\fI{ok, pending_process}\fR\&or \fI{ok, pending_process, reference()}\fR\&:
The unload request is registered, but there are still other \fBusers\fR\& holding the driver\&. Note that the term \fIpending_process\fR\& might refer to the running process, there might be more than one \fBuser\fR\& in the same process\&.
.RS 2
.LP
This is a normal, healthy return value if the call was just placed to inform the emulator that you have no further use of the driver\&. It is actually the most common return value in the most common \fBscenario\fR\& described in the introduction\&.
.RE
.RE
.LP
The function accepts the following parameters:
.RS 2
.TP 2
.B
\fIName\fR\&:
The name parameter is the name of the driver to be unloaded\&. The name can be specified either as an \fIio_list()\fR\& or as an \fIatom()\fR\&\&.
.TP 2
.B
\fIOptionList\fR\&:
The \fIOptionList\fR\& argument can be used to specify certain behavior regarding ports as well as triggering monitors under certain conditions:
.RS 2
.TP 2
.B
\fIkill_ports\fR\&:
Force killing of all ports opened using this driver, with the exit reason \fIdriver_unloaded\fR\&, if you are the \fIlast\fR\&\fBuser\fR\& of the driver\&.
.RS 2
.LP
If there are other \fBusers\fR\& having the driver loaded, this option will have no effect\&.
.RE
.RS 2
.LP
If one wants the consistent behavior of killing ports when the last \fBuser\fR\& unloads, one should use the driver option \fIkill_ports\fR\& when loading the driver instead\&.
.RE
.TP 2
.B
\fI{monitor, MonitorOption}\fR\&:
This option creates a driver monitor if the condition given in \fIMonitorOptions\fR\& is true\&. The valid options are:
.RS 2
.TP 2
.B
\fIpending_driver\fR\&:
Create a driver monitor if the return value is to be \fI{ok, pending_driver}\fR\&\&.
.TP 2
.B
\fIpending\fR\&:
Create a monitor if the return value will be either \fI{ok, pending_driver}\fR\& or \fI{ok, pending_process}\fR\&\&.
.RE
.RS 2
.LP
The \fIpending_driver\fR\& \fIMonitorOption\fR\& is by far the most useful and it has to be used to ensure that the driver has really been unloaded and the ports closed whenever the \fIkill_ports\fR\& option is used or the driver may have been loaded with the \fIkill_ports\fR\& driver option\&.
.RE
.RS 2
.LP
By using the monitor-triggers in the call to \fItry_unload\fR\& one can be sure that the monitor is actually added before the unloading is executed, meaning that the monitor will always get properly triggered, which would not be the case if one called \fIerl_ddll:monitor/2\fR\& separately\&.
.RE
.RE
.RE
.LP
The function may return several error conditions, of which all are well specified (no opaque values):
.RS 2
.TP 2
.B
\fI{error, linked_in_driver}\fR\&:
You were trying to unload an erlang statically linked in driver, which cannot be manipulated with this interface (and cannot be unloaded at all)\&.
.TP 2
.B
\fI{error, not_loaded}\fR\&:
The driver \fIName\fR\& is not present in the system\&.
.TP 2
.B
\fI{error, not_loaded_by_this_process}\fR\&:
The driver \fIName\fR\& is present in the system, but there is no \fBuser\fR\& of it in this process\&.
.RS 2
.LP
As a special case, drivers can be unloaded from processes that has done no corresponding call to \fItry_load/3\fR\& if, and only if, there are \fIno users of the driver at all\fR\&, which may happen if the process containing the last user dies\&.
.RE
.TP 2
.B
\fI{error, permanent}\fR\&:
The driver has made itself permanent, in which case it can no longer be manipulated by this interface (much like a statically linked in driver)\&.
.RE
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.nf

.B
unload(Name) -> ok | {error, ErrorDesc}
.br
.fi
.br
.RS
.TP 3
Types:

Name = \fBdriver()\fR\&
.br
ErrorDesc = term()
.br
.RE
.RS
.LP
Unloads, or at least dereferences the driver named \fIName\fR\&\&. If the caller is the last \fBuser\fR\& of the driver, and there are no more open ports using the driver, the driver will actually get unloaded\&. In all other cases, actual unloading will be delayed until all ports are closed and there are no remaining \fBusers\fR\&\&.
.LP
If there are other \fBusers\fR\& of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a user of the driver\&. For usage scenarios, see the \fBdescription\fR\& in the beginning of this document\&.
.LP
The \fIErrorDesc\fR\& returned is an opaque value to be passed further on to the \fBformat_error/1\fR\& function\&. For more control over the operation, use the \fBtry_unload/2\fR\& interface\&.
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.nf

.B
unload_driver(Name) -> ok | {error, ErrorDesc}
.br
.fi
.br
.RS
.TP 3
Types:

Name = \fBdriver()\fR\&
.br
ErrorDesc = term()
.br
.RE
.RS
.LP
Unloads, or at least dereferences the driver named \fIName\fR\&\&. If the caller is the last \fBuser\fR\& of the driver, all remaining open ports using the driver will get killed with the reason \fIdriver_unloaded\fR\& and the driver will eventually get unloaded\&.
.LP
If there are other \fBusers\fR\& of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a \fBuser\fR\&\&. For usage scenarios, see the \fBdescription\fR\& in the beginning of this document\&.
.LP
The \fIErrorDesc\fR\& returned is an opaque value to be passed further on to the \fBformat_error/1\fR\& function\&. For more control over the operation, use the \fBtry_unload/2\fR\& interface\&.
.LP
The function throws a \fIbadarg\fR\& exception if the parameters are not given as described above\&.
.RE
.LP
.B
loaded_drivers() -> {ok, Drivers}
.br
.RS
.TP 3
Types:

Drivers = [Driver]
.br
Driver = string()
.br
.RE
.RS
.LP
Returns a list of all the available drivers, both (statically) linked-in and dynamically loaded ones\&.
.LP
The driver names are returned as a list of strings rather than a list of atoms for historical reasons\&.
.LP
More information about drivers can be obtained using one of the \fBinfo\fR\& functions\&.
.RE
.LP
.nf

.B
format_error(ErrorDesc) -> string()
.br
.fi
.br
.RS
.TP 3
Types:

ErrorDesc = term()
.br
.RE
.RS
.LP
Takes an \fIErrorDesc\fR\& returned by load, unload or reload functions and returns a string which describes the error or warning\&.
.LP

.RS -4
.B
Note:
.RE
Due to peculiarities in the dynamic loading interfaces on different platform, the returned string is only guaranteed to describe the correct error \fIif format_error/1 is called in the same instance of the erlang virtual machine as the error appeared in\fR\& (meaning the same operating system process)!

.RE
.SH "SEE ALSO"

.LP
erl_driver(4), driver_entry(4)